// Auto-generated from Website Builder global JS
export const GLOBAL_JS = "\n\n/* wb:contrast-guard:v1 */\n(function () {\n  try {\n    var MIN_RATIO_TEXT = 4.5;\n    var MIN_RATIO_LARGE = 3.0;\n    var MIN_RATIO_UI = 3.0;\n\n    function clamp01(x) { return Math.max(0, Math.min(1, x)); }\n\n    function parseRgbFunc(input) {\n      // Supports: rgb(r,g,b) / rgba(r,g,b,a)\n      if (!input) return null;\n      var m = String(input).trim().match(/rgba?(([^)]+))/i);\n      if (!m) return null;\n      var parts = m[1].split(',').map(function (p) { return p.trim(); });\n      if (parts.length < 3) return null;\n      var r = parseFloat(parts[0]);\n      var g = parseFloat(parts[1]);\n      var b = parseFloat(parts[2]);\n      var a = parts.length >= 4 ? parseFloat(parts[3]) : 1;\n      if ([r,g,b,a].some(function (v) { return Number.isNaN(v); })) return null;\n      return { r: r, g: g, b: b, a: clamp01(a) };\n    }\n\n    function parseHex(input) {\n      if (!input) return null;\n      var s = String(input).trim();\n      if (s[0] !== '#') return null;\n      s = s.slice(1);\n      if (s.length === 3) {\n        var r = parseInt(s[0] + s[0], 16);\n        var g = parseInt(s[1] + s[1], 16);\n        var b = parseInt(s[2] + s[2], 16);\n        return { r: r, g: g, b: b, a: 1 };\n      }\n      if (s.length === 4) {\n        var r4 = parseInt(s[0] + s[0], 16);\n        var g4 = parseInt(s[1] + s[1], 16);\n        var b4 = parseInt(s[2] + s[2], 16);\n        var a4 = parseInt(s[3] + s[3], 16) / 255;\n        return { r: r4, g: g4, b: b4, a: clamp01(a4) };\n      }\n      if (s.length === 6 || s.length === 8) {\n        var r6 = parseInt(s.slice(0, 2), 16);\n        var g6 = parseInt(s.slice(2, 4), 16);\n        var b6 = parseInt(s.slice(4, 6), 16);\n        var a6 = s.length === 8 ? parseInt(s.slice(6, 8), 16) / 255 : 1;\n        return { r: r6, g: g6, b: b6, a: clamp01(a6) };\n      }\n      return null;\n    }\n\n    function hslToRgb(h, s, l) {\n      // h: 0..360, s/l: 0..1\n      h = ((h % 360) + 360) % 360;\n      var c = (1 - Math.abs(2 * l - 1)) * s;\n      var x = c * (1 - Math.abs(((h / 60) % 2) - 1));\n      var m = l - c / 2;\n      var r1 = 0, g1 = 0, b1 = 0;\n      if (h < 60) { r1 = c; g1 = x; b1 = 0; }\n      else if (h < 120) { r1 = x; g1 = c; b1 = 0; }\n      else if (h < 180) { r1 = 0; g1 = c; b1 = x; }\n      else if (h < 240) { r1 = 0; g1 = x; b1 = c; }\n      else if (h < 300) { r1 = x; g1 = 0; b1 = c; }\n      else { r1 = c; g1 = 0; b1 = x; }\n      return {\n        r: Math.round((r1 + m) * 255),\n        g: Math.round((g1 + m) * 255),\n        b: Math.round((b1 + m) * 255),\n        a: 1,\n      };\n    }\n\n    function parseHslFunc(input) {\n      if (!input) return null;\n      var m = String(input).trim().match(/hsla?(([^)]+))/i);\n      if (!m) return null;\n      var parts = m[1].split(',').map(function (p) { return p.trim(); });\n      if (parts.length < 3) return null;\n      var h = parseFloat(parts[0]);\n      var sRaw = parts[1];\n      var lRaw = parts[2];\n      var s = sRaw.indexOf('%') !== -1 ? parseFloat(sRaw) / 100 : parseFloat(sRaw);\n      var l = lRaw.indexOf('%') !== -1 ? parseFloat(lRaw) / 100 : parseFloat(lRaw);\n      var a = parts.length >= 4 ? parseFloat(parts[3]) : 1;\n      if ([h,s,l,a].some(function (v) { return Number.isNaN(v); })) return null;\n      var rgb = hslToRgb(h, clamp01(s), clamp01(l));\n      rgb.a = clamp01(a);\n      return rgb;\n    }\n\n    function parseColor(input) {\n      if (!input) return null;\n      var s = String(input).trim().toLowerCase();\n      // Important: many AI templates use gradient text with color: transparent\n      // and -webkit-text-fill-color: transparent. Treat transparent as alpha=0.\n      if (s === 'transparent') return { r: 0, g: 0, b: 0, a: 0 };\n      return parseRgbFunc(input) || parseHex(input) || parseHslFunc(input);\n    }\n\n    function extractFirstColorFromBackgroundImage(bgImage) {\n      // Attempt to pull first color stop from gradients like:\n      // linear-gradient(135deg, rgba(...), #fff 60%, ...)\n      if (!bgImage) return null;\n      var s = String(bgImage);\n      if (!s || s === 'none') return null;\n      // Match rgba()/rgb()/hsla()/hsl()/#hex\n      // IMPORTANT: Many gradients start with transparent/0-alpha stops.\n      // We want the first *non-transparent* color stop when possible.\n      var re = /(rgba?([^)]+)|hsla?([^)]+)|#[0-9a-fA-F]{3,8})/g;\n      var m;\n      var first = null;\n      while ((m = re.exec(s)) !== null) {\n        var c = parseColor(m[1]);\n        if (!c) continue;\n        if (!first) first = c;\n        // Prefer a non-transparent stop; otherwise gradients can be mis-read as white background\n        // (which makes us pick dark text on an actually-dark background).\n        if (c.a > 0.15) return c;\n      }\n      return first;\n    }\n\n    function srgbToLinear(c) {\n      c = c / 255;\n      return c <= 0.04045 ? (c / 12.92) : Math.pow((c + 0.055) / 1.055, 2.4);\n    }\n\n    function luminance(rgb) {\n      var r = srgbToLinear(rgb.r);\n      var g = srgbToLinear(rgb.g);\n      var b = srgbToLinear(rgb.b);\n      return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    }\n\n    function contrastRatio(fg, bg) {\n      var L1 = luminance(fg);\n      var L2 = luminance(bg);\n      var lighter = Math.max(L1, L2);\n      var darker = Math.min(L1, L2);\n      return (lighter + 0.05) / (darker + 0.05);\n    }\n\n    function blendOver(bg, fg) {\n      // alpha blend fg over bg\n      var a = clamp01(fg.a);\n      return {\n        r: bg.r * (1 - a) + fg.r * a,\n        g: bg.g * (1 - a) + fg.g * a,\n        b: bg.b * (1 - a) + fg.b * a,\n        a: 1,\n      };\n    }\n\n    function getEffectiveBackground(el) {\n      // Walk up until we find a non-transparent background.\n      // Fallback: white.\n      var cur = el;\n      var safety = 0;\n      var bg = { r: 255, g: 255, b: 255, a: 1 };\n      while (cur && safety < 25) {\n        safety++;\n        var cs = window.getComputedStyle(cur);\n        var bgc = parseColor(cs.backgroundColor);\n        if (bgc && bgc.a > 0) {\n          bg = blendOver(bg, bgc);\n          // If opaque enough, stop.\n          if (bgc.a >= 0.95) return bg;\n        }\n\n        // Handle gradient/image backgrounds (common in AI output): backgroundColor may be transparent.\n        // We approximate by using the first color stop from background-image.\n        if (cs.backgroundImage && cs.backgroundImage !== 'none') {\n          var approx = extractFirstColorFromBackgroundImage(cs.backgroundImage);\n          if (approx) {\n            bg = blendOver(bg, approx);\n            // If the stop is (nearly) opaque, we can treat as a solid approximation.\n            // Otherwise keep walking up: many templates stack translucent overlays.\n            if (approx.a >= 0.95) return bg;\n          }\n        }\n        cur = cur.parentElement;\n      }\n      return bg;\n    }\n\n    function isUIElement(el) {\n      if (!el) return false;\n      var tag = (el.tagName || '').toLowerCase();\n      if (tag === 'button') return true;\n      if (tag === 'a' && (el.getAttribute('role') || '').toLowerCase() === 'button') return true;\n      if (tag === 'input') {\n        var type = (el.getAttribute('type') || '').toLowerCase();\n        return type === 'button' || type === 'submit' || type === 'reset';\n      }\n      return false;\n    }\n\n    function isTextElement(el) {\n      if (!el) return false;\n      var tag = (el.tagName || '').toLowerCase();\n      if (tag === 'script' || tag === 'style' || tag === 'svg' || tag === 'path') return false;\n      // Only elements that actually contain text.\n      return (el.textContent || '').trim().length > 0;\n    }\n\n    function shouldSkip(el) {\n      if (!el || !el.getAttribute) return true;\n      if (el.closest && el.closest('[data-wb-no-contrast-guard=\"true\"]')) return true;\n      return false;\n    }\n\n    function applyFix(el) {\n      if (!isTextElement(el) || shouldSkip(el)) return;\n\n      var cs = window.getComputedStyle(el);\n      if (cs.visibility === 'hidden' || cs.display === 'none') return;\n      if (cs.opacity && parseFloat(cs.opacity) === 0) return;\n\n      var fg = parseColor(cs.color);\n      if (!fg) return;\n\n      var bg = getEffectiveBackground(el);\n      // If the text is effectively transparent (common with gradient-text), treat as unreadable.\n      var ratio = fg.a < 0.15 ? 0 : contrastRatio(blendOver(bg, fg), bg);\n\n      var fontSize = parseFloat(cs.fontSize || '16');\n      var isLarge = fontSize >= 18;\n      var threshold = isUIElement(el) ? MIN_RATIO_UI : (isLarge ? MIN_RATIO_LARGE : MIN_RATIO_TEXT);\n\n      if (ratio >= threshold) return;\n\n      // Pick a safe color based on background luminance.\n      // (Dark bg -> light text; light bg -> dark text)\n      var bgLum = luminance(bg);\n      var safe = bgLum > 0.5\n        ? { r: 17, g: 24, b: 39, a: 1 }  // near-slate-900\n        : { r: 248, g: 250, b: 252, a: 1 }; // near-slate-50\n\n      // Double-check that our chosen safe color actually improves.\n      var safeRatio = contrastRatio(safe, bg);\n      if (safeRatio < threshold) {\n        // Fallback extremes\n        safe = bgLum > 0.5\n          ? { r: 0, g: 0, b: 0, a: 1 }\n          : { r: 255, g: 255, b: 255, a: 1 };\n      }\n\n      // Use !important to override AI-generated color rules (often with !important)\n      // and also handle gradient-text styles that rely on -webkit-text-fill-color.\n      try {\n        el.style.setProperty(\n          'color',\n          'rgb(' + Math.round(safe.r) + ',' + Math.round(safe.g) + ',' + Math.round(safe.b) + ')',\n          'important'\n        );\n\n        // If the template uses background-clip:text and text-fill-color, ensure text becomes visible.\n        el.style.setProperty(\n          '-webkit-text-fill-color',\n          'rgb(' + Math.round(safe.r) + ',' + Math.round(safe.g) + ',' + Math.round(safe.b) + ')',\n          'important'\n        );\n        el.style.setProperty(\n          'text-fill-color',\n          'rgb(' + Math.round(safe.r) + ',' + Math.round(safe.g) + ',' + Math.round(safe.b) + ')',\n          'important'\n        );\n      } catch (_) {\n        // Fallback (should be rare)\n        el.style.color = 'rgb(' + Math.round(safe.r) + ',' + Math.round(safe.g) + ',' + Math.round(safe.b) + ')';\n      }\n      el.setAttribute('data-wb-contrast-fixed', 'true');\n    }\n\n    function scan(root) {\n      var list = root.querySelectorAll('*');\n      for (var i = 0; i < list.length; i++) {\n        applyFix(list[i]);\n      }\n    }\n\n    // Initial scan\n    scan(document);\n\n    // Re-scan on DOM updates (AI animations/JS)\n    var mo = new MutationObserver(function (mutations) {\n      for (var i = 0; i < mutations.length; i++) {\n        var m = mutations[i];\n        if (m.type === 'childList') {\n          for (var j = 0; j < m.addedNodes.length; j++) {\n            var n = m.addedNodes[j];\n            if (n && n.nodeType === 1) scan(n);\n          }\n        } else if (m.type === 'attributes' && m.target) {\n          applyFix(m.target);\n        }\n      }\n    });\n    mo.observe(document.documentElement, { subtree: true, childList: true, attributes: true, attributeFilter: ['class', 'style'] });\n  } catch (e) {\n    // Silent fail\n  }\n})();\n";
